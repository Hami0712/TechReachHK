<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Final Project ‚Äî Maze Navigator</title>
<style>
  :root{
    --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --panel:#ffffff;      
    --ink:#0f172a;        
    --muted:#475569;      
    --accent:#2563eb;     
    --accent-2:#22c55e;   
    --accent-3:#f59e0b;   
    --accent-4:#ef4444;   
    --accent-5:#8b5cf6;   
    --line:#cbd5e1;       
    --chip:#eef2ff;
    --shadow: 0 10px 25px rgba(0,0,0,0.1);
    --shadow-hover: 0 20px 40px rgba(0,0,0,0.15);
    --good:#16a34a; 
    --bad:#dc2626;
  }
  *{ box-sizing:border-box; }
  html,body{ margin:0; padding:0; background:var(--bg); color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; min-height:100vh; }
  body{ font-size:18px; line-height:1.55; }
  .wrap{max-width:1200px; margin-inline:auto; padding:24px;}
  header{
    display:flex; align-items:center; gap:20px; margin-bottom:32px; 
    background:rgba(255,255,255,0.95); padding:24px; border-radius:20px; 
    box-shadow:var(--shadow); backdrop-filter:blur(10px);
  }
  header .logo{
    width:60px;height:60px; border-radius:16px; 
    background:linear-gradient(135deg,var(--accent),#60a5fa); 
    display:grid; place-items:center; color:#fff; font-weight:800; font-size:24px;
    box-shadow: 0 8px 16px rgba(37, 99, 235, 0.3);
  }
  h1{font-size:clamp(28px,4vw,42px); margin:0; background:linear-gradient(135deg,var(--accent),var(--accent-2)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;}
  .subtitle{color:var(--muted); margin-top:8px; font-size:18px;}
  
  /* Language toggle */
  .lang-toggle{
    margin-left:auto; display:flex; align-items:center; gap:8px;
    background:rgba(255,255,255,0.1); padding:8px 16px; 
    border-radius:20px; border:1px solid rgba(255,255,255,0.2);
    backdrop-filter:blur(10px); transition:all 0.3s ease;
  }
  .lang-toggle:hover{background:rgba(255,255,255,0.2);}
  .lang-toggle button{
    background:none; border:none; color:var(--ink); font-size:14px; 
    font-weight:600; padding:4px 8px; border-radius:8px; 
    cursor:pointer; transition:all 0.2s ease;
  }
  .lang-toggle button.active{
    background:var(--accent); color:#fff; box-shadow:0 2px 8px rgba(37, 99, 235, 0.3);
  }
  .lang-toggle button:not(.active):hover{
    background:rgba(37, 99, 235, 0.1); color:var(--accent);
  }
  
  /* Navigation buttons - consistent sizing */
  .back-btn, .next-lesson-btn, .back-to-index-btn{
    background:var(--accent); color:#fff; border:none; padding:12px 20px; 
    border-radius:12px; font-weight:600; cursor:pointer; transition:all 0.3s ease;
    box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
    text-decoration:none; display:inline-flex; align-items:center; gap:8px;
    min-width: 140px; height: 48px; justify-content: center;
  }
  .back-btn:hover{
    background:#1d4ed8; transform:translateY(-2px); box-shadow: 0 6px 20px rgba(37, 99, 235, 0.4);
  }
  
  /* Next Lesson button specific styling */
  .next-lesson-btn{
    background:var(--accent-5); 
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
  }
  .next-lesson-btn:hover{
    background:#7c3aed; transform:translateY(-2px); box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
  }
  
  /* Back to All Lessons button specific styling */
  .back-to-index-btn{
    background:var(--accent-2); 
    box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
  }
  .back-to-index-btn:hover{
    background:#16a34a; transform:translateY(-2px); box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
  }
  
  main{ max-width:1200px; margin:0 auto; padding:16px; }
  .card{ 
    background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
    backdrop-filter: blur(5px); border:2px solid var(--line); border-radius:16px; 
    padding:16px; margin:12px 0; box-shadow:var(--shadow); transition:all 0.3s ease;
  }
  .card:hover{ transform:translateY(-2px); box-shadow:var(--shadow-hover); }
  .row{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
  button, .btn, select, input[type="number"]{
    font-size:18px; padding:10px 14px; border-radius:10px; border:2px solid #0f1720; background:#fff; color:#0f1720;
  }
  button:hover, .btn:hover{ outline:3px solid var(--accent); cursor:pointer; }
  button:focus, .btn:focus, select:focus, input:focus{ outline:4px solid var(--accent); }
  .hint{ background:#fff; border-left:6px solid var(--accent); padding:10px; border-radius:8px; }
  .good{ color:var(--good); font-weight:700; }
  .bad{ color:var(--bad); font-weight:700; }
  .sr{ position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }
  .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#fff; border-radius:6px; padding:2px 6px; border:1px solid #0f1720; }
  
  /* Game grid */
  .board{ display:grid; grid-template-columns: repeat(12, 40px); gap:4px; margin:20px auto; }
  .cell{ width:40px; height:40px; border:2px solid #0f1720; border-radius:6px; display:flex; align-items:center; justify-content:center; background:#fff; position:relative; }
  .start{ background:#d1fae5; }
  .goal{ background:#fde68a; }
  .wall{ background:#c7d2fe; position:relative; }
  .wall::after{ content:""; position:absolute; inset:6px; border:2px solid #0f1720; border-style:dashed; border-radius:4px; opacity:.8; }
  .visited{ 
    background:#e0e7ff; 
    position: relative;
  }
  .visited::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 8px;
    height: 8px;
    background: #3b82f6;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    animation: fadeIn 0.3s ease-in-out;
  }
  .current{ 
    background:#fef3c7; 
    box-shadow: 0 0 0 2px #f59e0b;
    animation: pulse 1s infinite;
  }
  
  @keyframes fadeIn {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
    100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  }
  
  @keyframes pulse {
    0%, 100% { box-shadow: 0 0 0 2px #f59e0b; }
    50% { box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.5); }
  }
  
  /* Animation overlay */
  .boardWrap{ position:relative; display:inline-block; }
  #robot{ 
    position:absolute; top:2px; left:2px; width:36px; height:36px; 
    display:flex; align-items:center; justify-content:center; 
    pointer-events:none; will-change:transform; 
    transition: transform 400ms cubic-bezier(0.4, 0, 0.2, 1); 
    font-size:20px; z-index:10;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
  }
  
  /* Robot animation states */
  #robot.moving {
    animation: robotMove 400ms ease-in-out;
  }
  
  #robot.turning {
    animation: robotTurn 300ms ease-in-out;
  }
  
  #robot.success {
    animation: robotSuccess 600ms ease-in-out;
  }
  
  @keyframes robotMove {
    0% { transform: scale(1) rotate(0deg); }
    50% { transform: scale(1.2) rotate(0deg); }
    100% { transform: scale(1) rotate(0deg); }
  }
  
  @keyframes robotTurn {
    0% { transform: scale(1) rotate(0deg); }
    50% { transform: scale(1.1) rotate(180deg); }
    100% { transform: scale(1) rotate(0deg); }
  }
  
  @keyframes robotSuccess {
    0% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(1.3) rotate(-10deg); }
    50% { transform: scale(1.3) rotate(10deg); }
    75% { transform: scale(1.3) rotate(-10deg); }
    100% { transform: scale(1) rotate(0deg); }
  }
  
  /* Sensor display */
  .sensors{ display:grid; grid-template-columns: repeat(4, 1fr); gap:12px; margin:16px 0; }
  .sensor{ background:#fff; padding:12px; border-radius:8px; border:2px solid #0f1720; text-align:center; }
  .sensor.active{ background:#fef3c7; border-color:#f59e0b; }
  .sensor-name{ font-size:14px; font-weight:600; margin-bottom:4px; }
  .sensor-value{ font-size:18px; font-weight:700; }
  
  /* Code editor */
  .code-editor{ 
    width:100%; 
    min-height:200px; 
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; 
    font-size:16px; 
    background:#1e293b; 
    color:#e2e8f0; 
    resize:vertical;
    border:2px solid #0f1720;
    border-radius:8px;
    padding:12px;
  }
  
  /* Progress */
  .progress{ display:flex; gap:8px; margin:16px 0; }
  .progress-item{ width:40px; height:40px; border-radius:50%; border:3px solid #0f1720; display:flex; align-items:center; justify-content:center; font-weight:700; }
  .progress-item.completed{ background:var(--good); color:#fff; }
  .progress-item.current{ background:var(--accent); color:#fff; }
  .progress-item.failed{ background:var(--bad); color:#fff; }
  
  /* Test results */
  .test-results{ display:grid; grid-template-columns: repeat(5, 1fr); gap:12px; margin:16px 0; }
  .test-result{ padding:12px; border-radius:8px; border:2px solid #0f1720; text-align:center; }
  .test-result.passed{ background:#d1fae5; border-color:var(--good); }
  .test-result.failed{ background:#fee2e2; border-color:var(--bad); }
  .test-result.pending{ background:#f3f4f6; border-color:#6b7280; }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo" aria-hidden="true">üèÜ</div>
      <div>
        <h1 data-en="Final Project - Maze Navigator" data-zh="ÊúÄÁµÇÈ†ÖÁõÆ - Ëø∑ÂÆÆÂ∞éËà™Âô®">Final Project - Maze Navigator</h1>
        <div class="subtitle" data-en="Write a program that can navigate ANY maze to find the star! Test your code on 5 random mazes." data-zh="Á∑®ÂØ´‰∏ÄÂÄãÂèØ‰ª•Â∞éËà™‰ªª‰ΩïËø∑ÂÆÆÊâæÂà∞ÊòüÊòüÁöÑÁ®ãÂ∫èÔºÅÂú®5ÂÄãÈö®Ê©üËø∑ÂÆÆ‰∏äÊ∏¨Ë©¶‰Ω†ÁöÑ‰ª£Á¢º„ÄÇ">Write a program that can navigate ANY maze to find the star! Test your code on 5 random mazes.</div>
      </div>
      <div class="lang-toggle">
        <button class="active" onclick="switchLanguage('en')">EN</button>
        <button onclick="switchLanguage('zh')">ÁπÅ‰∏≠</button>
      </div>
    </header>
    
    <div style="margin-bottom: 20px; display: flex; gap: 12px; align-items: center;">
      <a href="9. Smart Home AND OR NOT.html" class="back-btn">
        ‚Üê <span data-en="Previous Lesson" data-zh="‰∏ä‰∏ÄË™≤">Previous Lesson</span>
      </a>
      <button id="nextLessonBtn" class="next-lesson-btn" data-en="Back to All Lessons" data-zh="ËøîÂõûÈ¶ñÈ†Å">Back to All Lessons</button>
      <button id="backToIndexBtn" class="back-to-index-btn" data-en="Back to All Lessons" data-zh="ËøîÂõûÈ¶ñÈ†Å">Back to All Lessons</button>
    </div>

    <main>
  <!-- Progress -->
  <div class="card">
    <h3>üéØ Test Progress</h3>
    <div class="progress">
      <div class="progress-item" id="test-1">1</div>
      <div class="progress-item" id="test-2">2</div>
      <div class="progress-item" id="test-3">3</div>
      <div class="progress-item" id="test-4">4</div>
      <div class="progress-item" id="test-5">5</div>
    </div>
    <div class="test-results">
      <div class="test-result pending" id="result-1">Test 1<br>Pending</div>
      <div class="test-result pending" id="result-2">Test 2<br>Pending</div>
      <div class="test-result pending" id="result-3">Test 3<br>Pending</div>
      <div class="test-result pending" id="result-4">Test 4<br>Pending</div>
      <div class="test-result pending" id="result-5">Test 5<br>Pending</div>
    </div>
  </div>

  <!-- Current Maze -->
  <div class="card">
    <h3 data-en="üó∫Ô∏è Current Maze" data-zh="üó∫Ô∏è Áï∂ÂâçËø∑ÂÆÆ">üó∫Ô∏è Current Maze</h3>
    <div class="boardWrap">
      <div class="board" id="board"></div>
      <div id="robot">ü§ñ</div>
    </div>
  </div>

  <!-- Robot Sensors -->
  <div class="card">
    <h3 data-en="üì° Robot Sensors" data-zh="üì° Ê©üÂô®‰∫∫ÊÑüÊáâÂô®">üì° Robot Sensors</h3>
    <div class="sensors">
      <div class="sensor" id="sensor-up">
        <div class="sensor-name" data-en="Up" data-zh="‰∏ä">Up</div>
        <div class="sensor-value" id="up-value">Clear</div>
      </div>
      <div class="sensor" id="sensor-right">
        <div class="sensor-name" data-en="Right" data-zh="Âè≥">Right</div>
        <div class="sensor-value" id="right-value">Clear</div>
      </div>
      <div class="sensor" id="sensor-down">
        <div class="sensor-name" data-en="Down" data-zh="‰∏ã">Down</div>
        <div class="sensor-value" id="down-value">Clear</div>
      </div>
      <div class="sensor" id="sensor-left">
        <div class="sensor-name" data-en="Left" data-zh="Â∑¶">Left</div>
        <div class="sensor-value" id="left-value">Clear</div>
      </div>
    </div>
  </div>

  <!-- Programming Interface -->
  <div class="card">
    <h3 data-en="üíª Write Your Navigation Program" data-zh="üíª Á∑®ÂØ´‰Ω†ÁöÑÂ∞éËà™Á®ãÂºè">üíª Write Your Navigation Program</h3>
    <div class="hint">
      <strong data-en="Available Commands:" data-zh="ÂèØÁî®Êåá‰ª§Ôºö">Available Commands:</strong><br>
      <span class="kbd">right(steps)</span> <span data-en="- Move right (default: 1 step)" data-zh="- ÂêëÂè≥ÁßªÂãïÔºàÈ†êË®≠Ôºö1Ê≠•Ôºâ">- Move right (default: 1 step)</span><br>
      <span class="kbd">left(steps)</span> <span data-en="- Move left (default: 1 step)" data-zh="- ÂêëÂ∑¶ÁßªÂãïÔºàÈ†êË®≠Ôºö1Ê≠•Ôºâ">- Move left (default: 1 step)</span><br>
      <span class="kbd">up(steps)</span> <span data-en="- Move up (default: 1 step)" data-zh="- Âêë‰∏äÁßªÂãïÔºàÈ†êË®≠Ôºö1Ê≠•Ôºâ">- Move up (default: 1 step)</span><br>
      <span class="kbd">down(steps)</span> <span data-en="- Move down (default: 1 step)" data-zh="- Âêë‰∏ãÁßªÂãïÔºàÈ†êË®≠Ôºö1Ê≠•Ôºâ">- Move down (default: 1 step)</span><br>
      <span class="kbd">wall_up()</span> <span data-en="- Check if wall above" data-zh="- Ê™¢Êü•‰∏äÊñπÊòØÂê¶ÊúâÁâÜ">- Check if wall above</span><br>
      <span class="kbd">wall_down()</span> <span data-en="- Check if wall below" data-zh="- Ê™¢Êü•‰∏ãÊñπÊòØÂê¶ÊúâÁâÜ">- Check if wall below</span><br>
      <span class="kbd">wall_left()</span> <span data-en="- Check if wall on left" data-zh="- Ê™¢Êü•Â∑¶ÊñπÊòØÂê¶ÊúâÁâÜ">- Check if wall on left</span><br>
      <span class="kbd">wall_right()</span> <span data-en="- Check if wall on right" data-zh="- Ê™¢Êü•Âè≥ÊñπÊòØÂê¶ÊúâÁâÜ">- Check if wall on right</span><br>
      <span class="kbd">at_goal()</span> <span data-en="- Check if reached the star" data-zh="- Ê™¢Êü•ÊòØÂê¶Âà∞ÈÅîÊòüÊòü">- Check if reached the star</span><br>
      <span class="kbd">if (condition) { commands }</span> <span data-en="- Conditional logic" data-zh="- Ê¢ù‰ª∂ÈÇèËºØ">- Conditional logic</span><br>
      <span class="kbd">repeat (times) { commands }</span> <span data-en="- Repeat commands" data-zh="- ÈáçË§áÊåá‰ª§">- Repeat commands</span><br>
      <span class="kbd">and(condition1, condition2)</span> <span data-en="- AND logic" data-zh="- ANDÈÇèËºØ">- AND logic</span><br>
      <span class="kbd">or(condition1, condition2)</span> <span data-en="- OR logic" data-zh="- ORÈÇèËºØ">- OR logic</span><br>
      <span class="kbd">not(condition)</span> <span data-en="- NOT logic" data-zh="- NOTÈÇèËºØ">- NOT logic</span>
    </div>
    <textarea class="code-editor" id="code" placeholder="Write your navigation program here...">// Example: Simple navigation
right(3);
down(2);
right(2);
up(1);
right(6);</textarea>
    <div class="row mt">
      <button id="runBtn">‚ñ∂Ô∏è Run Program</button>
      <button id="resetBtn">üîÑ Reset</button>
      <button id="testBtn">üß™ Test All Mazes</button>
      <button id="newMazeBtn">üé≤ New Maze</button>
    </div>
  </div>

  <!-- Feedback -->
  <div class="card">
    <div id="feedback" class="hint">Ready to program! Write your navigation algorithm above.</div>
  </div>
</main>

<script>
let running = false;
let currentTest = 0;
let testResults = [null, null, null, null, null];
let currentMaze = null;
let robot = { x: 0, y: 0 };
let visited = new Set();
let steps = 0;
const maxSteps = 200;

// Maze generation
function generateMaze() {
  const maze = Array(12).fill().map(() => Array(12).fill(0)); // 0=empty, 1=wall
  
  // Add random walls (but ensure path exists)
  for (let i = 0; i < 12; i++) {
    for (let j = 0; j < 12; j++) {
      if (Math.random() < 0.3) { // 30% chance of wall
        maze[i][j] = 1;
      }
    }
  }
  
  // Ensure start and goal positions are clear
  maze[0][0] = 0; // Start position
  maze[11][11] = 0; // Goal position
  
  // Simple pathfinding to ensure there's always a path
  ensurePath(maze);
  
  return maze;
}

function ensurePath(maze) {
  // Simple flood fill to ensure connectivity
  const visited = Array(12).fill().map(() => Array(12).fill(false));
  const queue = [[0, 0]];
  visited[0][0] = true;
  
  while (queue.length > 0) {
    const [x, y] = queue.shift();
    
    if (x === 11 && y === 11) return true; // Path exists
    
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    for (const [dx, dy] of directions) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < 12 && ny >= 0 && ny < 12 && 
          !visited[nx][ny] && maze[nx][ny] === 0) {
        visited[nx][ny] = true;
        queue.push([nx, ny]);
      }
    }
  }
  
  // If no path exists, clear some walls
  for (let i = 0; i < 12; i++) {
    for (let j = 0; j < 12; j++) {
      if (maze[i][j] === 1 && Math.random() < 0.5) {
        maze[i][j] = 0;
      }
    }
  }
  
  return ensurePath(maze); // Recursive call
}

function drawMaze() {
  const board = document.getElementById('board');
  board.innerHTML = '';
  
  for (let i = 0; i < 12; i++) {
    for (let j = 0; j < 12; j++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.id = `cell-${i}-${j}`;
      
      if (i === 0 && j === 0) {
        cell.classList.add('start');
      } else if (i === 11 && j === 11) {
        cell.classList.add('goal');
        cell.textContent = '‚≠ê';
      } else if (currentMaze[i][j] === 1) {
        cell.classList.add('wall');
      }
      
      board.appendChild(cell);
    }
  }
  
  updateRobotPosition();
  updateSensors();
}

function updateRobotPosition(animate = false) {
  const robotEl = document.getElementById('robot');
  const x = robot.y * 44 + 2; // 40px cell + 4px gap + 2px offset
  const y = robot.x * 44 + 2; // 40px cell + 4px gap + 2px offset
  
  // Remove any existing animation classes
  robotEl.classList.remove('moving', 'turning', 'success');
  
  if (animate) {
    // Add moving animation
    robotEl.classList.add('moving');
    setTimeout(() => {
      robotEl.classList.remove('moving');
    }, 400);
  }
  
  robotEl.style.transform = `translate(${x}px, ${y}px)`;
  
  // Update visited cells
  document.querySelectorAll('.visited').forEach(cell => cell.classList.remove('visited'));
  visited.forEach(pos => {
    const [x, y] = pos.split(',').map(Number);
    const cell = document.getElementById(`cell-${x}-${y}`);
    if (cell && !cell.classList.contains('start') && !cell.classList.contains('goal')) {
      cell.classList.add('visited');
    }
  });
  
  // Highlight current position
  const currentCell = document.getElementById(`cell-${robot.x}-${robot.y}`);
  if (currentCell) {
    currentCell.classList.add('current');
  }
}

function updateSensors() {
  const sensors = {
    up: wall_up(),
    right: wall_right(),
    down: wall_down(),
    left: wall_left()
  };
  
  Object.entries(sensors).forEach(([direction, hasWall]) => {
    const sensorEl = document.getElementById(`sensor-${direction}`);
    const valueEl = document.getElementById(`${direction}-value`);
    
    if (hasWall) {
      sensorEl.classList.add('active');
      valueEl.textContent = 'Wall';
    } else {
      sensorEl.classList.remove('active');
      valueEl.textContent = 'Clear';
    }
  });
}

// Sensor functions - check for walls in each direction
function wall_right() {
  const ny = robot.y + 1;
  return ny >= 12 || currentMaze[robot.x][ny] === 1;
}

function wall_left() {
  const ny = robot.y - 1;
  return ny < 0 || currentMaze[robot.x][ny] === 1;
}

function wall_up() {
  const nx = robot.x - 1;
  return nx < 0 || currentMaze[nx][robot.y] === 1;
}

function wall_down() {
  const nx = robot.x + 1;
  return nx >= 12 || currentMaze[nx][robot.y] === 1;
}

// Robot movement commands
function right(steps = 1) {
  for (let i = 0; i < steps; i++) {
    const ny = robot.y + 1;
    if (ny < 12 && currentMaze[robot.x][ny] === 0) {
      robot.y = ny;
      visited.add(`${robot.x},${robot.y}`);
      updateRobotPosition(true);
    } else {
      return false; // Hit wall or boundary
    }
  }
  return true;
}

function left(steps = 1) {
  for (let i = 0; i < steps; i++) {
    const ny = robot.y - 1;
    if (ny >= 0 && currentMaze[robot.x][ny] === 0) {
      robot.y = ny;
      visited.add(`${robot.x},${robot.y}`);
      updateRobotPosition(true);
    } else {
      return false; // Hit wall or boundary
    }
  }
  return true;
}

function up(steps = 1) {
  for (let i = 0; i < steps; i++) {
    const nx = robot.x - 1;
    if (nx >= 0 && currentMaze[nx][robot.y] === 0) {
      robot.x = nx;
      visited.add(`${robot.x},${robot.y}`);
      updateRobotPosition(true);
    } else {
      return false; // Hit wall or boundary
    }
  }
  return true;
}

function down(steps = 1) {
  for (let i = 0; i < steps; i++) {
    const nx = robot.x + 1;
    if (nx < 12 && currentMaze[nx][robot.y] === 0) {
      robot.x = nx;
      visited.add(`${robot.x},${robot.y}`);
      updateRobotPosition(true);
    } else {
      return false; // Hit wall or boundary
    }
  }
  return true;
}


function at_goal() {
  return robot.x === 11 && robot.y === 11;
}

// Logic functions
function and(a, b) { return a && b; }
function or(a, b) { return a || b; }
function not(a) { return !a; }

// Program execution
function parseProgram(src) {
  const lines = src.split('\n').filter(line => line.trim() && !line.trim().startsWith('//'));
  const commands = [];
  
  for (const line of lines) {
    const trimmed = line.trim();
    
    // Handle movement commands with optional steps
    const moveMatch = trimmed.match(/^(right|left|up|down)\((\d+)?\)$/);
    if (moveMatch) {
      const direction = moveMatch[1];
      const steps = moveMatch[2] ? parseInt(moveMatch[2]) : 1;
      commands.push({ type: 'command', name: direction, steps });
    }
    // Handle if statements
    else if (trimmed.startsWith('if (')) {
      const condition = trimmed.match(/if \(([^)]+)\)/)[1];
      commands.push({ type: 'if', condition });
    } else if (trimmed.startsWith('}')) {
      commands.push({ type: 'end_block' });
    }
    // Handle repeat loops
    else if (trimmed.startsWith('repeat (')) {
      const times = parseInt(trimmed.match(/repeat \((\d+)\)/)[1]);
      commands.push({ type: 'repeat', times });
    }
    // Handle other function calls
    else if (trimmed.includes('(') && trimmed.includes(')')) {
      const match = trimmed.match(/(\w+)\(\)/);
      if (match) {
        commands.push({ type: 'command', name: match[1] });
      }
    }
  }
  
  return commands;
}

async function runProgram() {
  if (running) return;
  running = true;
  
  try {
    const src = document.getElementById('code').value;
    const commands = parseProgram(src);
    
    // Reset robot
    robot = { x: 0, y: 0 };
    visited.clear();
    visited.add('0,0');
    steps = 0;
    drawMaze();
    
    setFeedback('ü§ñ Running program...', 'muted');
    
    // Add initial robot animation
    const robotEl = document.getElementById('robot');
    robotEl.classList.add('moving');
    setTimeout(() => {
      robotEl.classList.remove('moving');
    }, 400);
    
    // Execute commands
    let i = 0;
    while (i < commands.length && steps < maxSteps) {
      const cmd = commands[i];
      
      if (cmd.type === 'command') {
        if (cmd.name === 'right') {
          if (!right(cmd.steps || 1)) {
            setFeedback('‚ùå Robot hit a wall!', 'bad');
            break;
          }
        } else if (cmd.name === 'left') {
          if (!left(cmd.steps || 1)) {
            setFeedback('‚ùå Robot hit a wall!', 'bad');
            break;
          }
        } else if (cmd.name === 'up') {
          if (!up(cmd.steps || 1)) {
            setFeedback('‚ùå Robot hit a wall!', 'bad');
            break;
          }
        } else if (cmd.name === 'down') {
          if (!down(cmd.steps || 1)) {
            setFeedback('‚ùå Robot hit a wall!', 'bad');
            break;
          }
        }
        
        await new Promise(r => setTimeout(r, 300));
        
        if (at_goal()) {
          // Add success animation
          const robotEl = document.getElementById('robot');
          robotEl.classList.add('success');
          setTimeout(() => {
            robotEl.classList.remove('success');
          }, 600);
          
          setFeedback('üéâ Success! Robot reached the star!', 'good');
          break;
        }
      } else if (cmd.type === 'if') {
        const condition = eval(cmd.condition);
        if (!condition) {
          // Skip to end of if block
          let depth = 1;
          i++;
          while (i < commands.length && depth > 0) {
            if (commands[i].type === 'if') depth++;
            if (commands[i].type === 'end_block') depth--;
            i++;
          }
          continue;
        }
      } else if (cmd.type === 'repeat') {
        // Simple repeat implementation
        const repeatTimes = cmd.times;
        let repeatCount = 0;
        i++;
        const startIndex = i;
        
        while (repeatCount < repeatTimes && i < commands.length) {
          const repeatCmd = commands[i];
          if (repeatCmd.type === 'command') {
            if (repeatCmd.name === 'right') {
              if (!right(repeatCmd.steps || 1)) break;
            } else if (repeatCmd.name === 'left') {
              if (!left(repeatCmd.steps || 1)) break;
            } else if (repeatCmd.name === 'up') {
              if (!up(repeatCmd.steps || 1)) break;
            } else if (repeatCmd.name === 'down') {
              if (!down(repeatCmd.steps || 1)) break;
            }
            await new Promise(r => setTimeout(r, 200));
          }
          i++;
          if (i >= commands.length) {
            i = startIndex;
            repeatCount++;
          }
        }
        continue;
      }
      
      i++;
    }
    
    if (steps >= maxSteps) {
      setFeedback('‚è∞ Program timed out after 200 steps', 'bad');
    } else if (!at_goal()) {
      setFeedback('ü§î Program finished but robot didn\'t reach the star', 'bad');
    }
    
  } catch (err) {
    setFeedback('‚ùå Error: ' + err.message, 'bad');
  }
  
  running = false;
}

async function testAllMazes() {
  if (running) return;
  
  setFeedback('üß™ Testing your program on 5 random mazes...', 'muted');
  
  // Reset test results
  testResults = [null, null, null, null, null];
  updateTestDisplay();
  
  for (let test = 0; test < 5; test++) {
    currentTest = test;
    updateTestDisplay();
    
    // Generate new maze
    currentMaze = generateMaze();
    drawMaze();
    
    // Run program
    running = true;
    let success = false;
    
    try {
      const src = document.getElementById('code').value;
      const commands = parseProgram(src);
      
      // Reset robot
      robot = { x: 0, y: 0 };
      visited.clear();
      visited.add('0,0');
      steps = 0;
      
      // Execute commands
      let i = 0;
      while (i < commands.length && steps < maxSteps) {
        const cmd = commands[i];
        
        if (cmd.type === 'command') {
          if (cmd.name === 'right') {
            if (!right(cmd.steps || 1)) break;
          } else if (cmd.name === 'left') {
            if (!left(cmd.steps || 1)) break;
          } else if (cmd.name === 'up') {
            if (!up(cmd.steps || 1)) break;
          } else if (cmd.name === 'down') {
            if (!down(cmd.steps || 1)) break;
          }
          
          if (at_goal()) {
            success = true;
            break;
          }
        }
        i++;
      }
      
    } catch (err) {
      success = false;
    }
    
    testResults[test] = success;
    updateTestDisplay();
    
    await new Promise(r => setTimeout(r, 1000));
  }
  
  // Final results
  const passedTests = testResults.filter(r => r === true).length;
  if (passedTests === 5) {
    setFeedback('üèÜ AMAZING! Your program passed all 5 tests! You\'re a programming master!', 'good');
  } else {
    setFeedback(`üìä Results: ${passedTests}/5 tests passed. Keep improving your algorithm!`, 'bad');
  }
  
  running = false;
}

function updateTestDisplay() {
  for (let i = 0; i < 5; i++) {
    const testEl = document.getElementById(`test-${i + 1}`);
    const resultEl = document.getElementById(`result-${i + 1}`);
    
    if (i === currentTest && running) {
      testEl.className = 'progress-item current';
      resultEl.className = 'test-result pending';
      resultEl.innerHTML = `Test ${i + 1}<br>Running...`;
    } else if (testResults[i] === true) {
      testEl.className = 'progress-item completed';
      resultEl.className = 'test-result passed';
      resultEl.innerHTML = `Test ${i + 1}<br>‚úÖ Passed`;
    } else if (testResults[i] === false) {
      testEl.className = 'progress-item failed';
      resultEl.className = 'test-result failed';
      resultEl.innerHTML = `Test ${i + 1}<br>‚ùå Failed`;
    } else {
      testEl.className = 'progress-item';
      resultEl.className = 'test-result pending';
      resultEl.innerHTML = `Test ${i + 1}<br>Pending`;
    }
  }
}

function newMaze() {
  if (running) return;
  currentMaze = generateMaze();
  drawMaze();
  setFeedback('üé≤ New maze generated! Try your program on this layout.', 'muted');
}

function reset() {
  if (running) return;
  robot = { x: 0, y: 0 };
  visited.clear();
  visited.add('0,0');
  steps = 0;
  drawMaze();
  setFeedback('üîÑ Robot reset to starting position.', 'muted');
}

function setFeedback(msg, cls) {
  const el = document.getElementById('feedback');
  el.className = cls ? cls : 'hint';
  el.textContent = msg;
}

// Navigation functions
function nextLesson() {
  window.location.href = '../index.html';
}

function backToIndex() {
  window.location.href = '../index.html';
}

// Initialize navigation buttons
function initializeNavigationButtons() {
  const nextLessonBtn = document.getElementById('nextLessonBtn');
  const backToIndexBtn = document.getElementById('backToIndexBtn');
  
  if (nextLessonBtn) {
    nextLessonBtn.addEventListener('click', nextLesson);
  }
  
  if (backToIndexBtn) {
    backToIndexBtn.addEventListener('click', backToIndex);
  }
}

// Language switching function
function switchLanguage(lang) {
  // Update all elements with data attributes
  document.querySelectorAll('[data-en][data-zh]').forEach(element => {
    if (lang === 'zh') {
      element.innerHTML = element.getAttribute('data-zh');
    } else {
      element.innerHTML = element.getAttribute('data-en');
    }
  });
  
  // Update active language button
  document.querySelectorAll('.lang-toggle button').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');
  
  // Update HTML lang attribute
  document.documentElement.lang = lang === 'zh' ? 'zh-Hant' : 'en';
  
  // Store language preference
  localStorage.setItem('preferredLanguage', lang);
}

// Initialize on DOM load
document.addEventListener('DOMContentLoaded', function() {
  initializeNavigationButtons();
  
  // Load saved language preference
  const savedLang = localStorage.getItem('preferredLanguage') || 'en';
  if (savedLang === 'zh') {
    // Update button states
    document.querySelectorAll('.lang-toggle button').forEach(btn => {
      btn.classList.remove('active');
    });
    document.querySelector('.lang-toggle button[onclick="switchLanguage(\'zh\')"]').classList.add('active');
    
    // Update content
    document.querySelectorAll('[data-en][data-zh]').forEach(element => {
      element.innerHTML = element.getAttribute('data-zh');
    });
    document.documentElement.lang = 'zh-Hant';
  }
});

// Initialize
currentMaze = generateMaze();
drawMaze();

// Event listeners
document.getElementById('runBtn').addEventListener('click', runProgram);
document.getElementById('resetBtn').addEventListener('click', reset);
document.getElementById('testBtn').addEventListener('click', testAllMazes);
document.getElementById('newMazeBtn').addEventListener('click', newMaze);

// Keyboard shortcuts
window.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
    e.preventDefault();
    runProgram();
  }
});
</script>
    </main>
  </div>
</body>
</html>
